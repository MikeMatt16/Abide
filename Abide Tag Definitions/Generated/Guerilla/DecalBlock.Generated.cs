//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Abide.Tag.Guerilla.Generated
{
    using System;
    using Abide.HaloLibrary;
    using Abide.Tag;
    
    /// <summary>
    /// Represents the generated decal_block tag block.
    /// </summary>
    public sealed class DecalBlock : Block
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DecalBlock"/> class.
        /// </summary>
        public DecalBlock()
        {
            this.Fields.Add(new ExplanationField("DECAL", "There are several \"layers\" which decals can be placed into, these layers are draw" +
                        "n in a specific order relative to the shader layers and each layer has its own s" +
                        "pecific blending mode. In general, the decal bitmap\'s alpha channel will be used" +
                        " as an opacity mask if it exists.\n\n* LIT ALPHA-BLEND PRELIGHT: Decals in this la" +
                        "yer are lit by the lightmap but are \"faded out\" by dynamic lights. What this mea" +
                        "ns is that dynamic lights hitting them will cause them to disappear, sort of. Th" +
                        "is layer is rendered immediately before lightmap shadows (and before dynamic lig" +
                        "hts).\n\n* LIT ALPHA-BLEND: Decals in this layer are lit by the lightmap but are N" +
                        "OT lit by dynamic lights. What this means is that if the decal exists in an area" +
                        " that has dark lightmapping but bright dynamic lighting, the decal will appear d" +
                        "ark. This layer is rendered immediately after dynamic lights, and all subsequent" +
                        " decal layers are rendered after this one in order.\n\n* DOUBLE MULTIPLY: Decals i" +
                        "n this layer will double-multiply the color in the framebuffer. Gray pixels in t" +
                        "he decal bitmap will be transparent (black darkens, white brightens). The decal " +
                        "color in the tag does NOT do anything!!\n\n* MULTIPLY: Decals in this layer will m" +
                        "ultiply the color in the framebuffer. White pixels in the decal bitmap will be t" +
                        "ransparent. The decal color (in the decal tag) does NOT do anything!!\n\n* MAX: De" +
                        "cals in this layer will perform a component-wise max operation on the framebuffe" +
                        "r, replacing color values with whichever is higher. Black pixels in the decal bi" +
                        "tmap will be transparent.\n\n* ADD: Decals in this layer will perform an addition " +
                        "operation on the framebuffer, replacing color values with the sum of the two. Bl" +
                        "ack pixels in the decal bitmap will be transparent.\n\n* ERROR: Decals in this lay" +
                        "er will render bright red and show through geometry!\n\nA compound decal is a chai" +
                        "n of decals which are instantiated simultaneously. Compound decals are created b" +
                        "y referencing another decal tag in the \'next_decal_in_chain\' field below. Do not" +
                        " attempt to create a circularly linked decal chain, i.e. A->B->C->A! This will c" +
                        "ause problems and probably hang the game. Also, do not reference a decal from an" +
                        " effect if it is not the head of the chain; for example an effect should not ins" +
                        "tantiate decal B if the chain was A->B->C. Compound decals can have seperate bit" +
                        "maps, etc., and can be drawn in seperate layers. In addition, we used to have th" +
                        "e ability for each decal in the chain can either inherit its parent\'s radius, ro" +
                        "tation, color, etc. - or it can randomly choose its own. This behavior was contr" +
                        "olled by the \'geometry_inherited_by_next_decal_in_chain\' flag, below but it\'s cu" +
                        "rrently broken."));
            this.Fields.Add(new WordFlagsField("flags", "geometry inherited by next decal in chain", "interpolate color in hsv", "...more colors", "no random rotation", "UNUSED", "SAPIEN- snap to axis", "SAPIEN- incremental counter", "UNUSED", "preserve aspect", "UNUSED"));
            this.Fields.Add(new EnumField("type#controls how the decal wraps onto surface geometry", "scratch", "splatter", "burn", "painted sign"));
            this.Fields.Add(new EnumField("layer", "lit alpha-blend prelight", "lit alpha-blend", "double multiply", "multiply", "max", "add", "error"));
            this.Fields.Add(new ShortIntegerField("max overlapping count"));
            this.Fields.Add(new TagReferenceField("next decal in chain", 1684366177));
            this.Fields.Add(new RealBoundsField("radius:world units#0 defaults to 0.125"));
            this.Fields.Add(new RealField("radius overlap rejection:muliplier"));
            this.Fields.Add(new RealRgbColorField("color lower bounds"));
            this.Fields.Add(new RealRgbColorField("color upper bounds"));
            this.Fields.Add(new RealBoundsField("lifetime:seconds"));
            this.Fields.Add(new RealBoundsField("decay time:seconds"));
            this.Fields.Add(new PadField("", 40));
            this.Fields.Add(new PadField("", 2));
            this.Fields.Add(new PadField("", 2));
            this.Fields.Add(new PadField("", 2));
            this.Fields.Add(new PadField("", 2));
            this.Fields.Add(new PadField("", 20));
            this.Fields.Add(new TagReferenceField("bitmap", 1651078253));
            this.Fields.Add(new PadField("", 20));
            this.Fields.Add(new RealField("maximum sprite extent*:pixels"));
            this.Fields.Add(new PadField("", 4));
        }
        /// <summary>
        /// Gets and returns the name of the decal_block tag block.
        /// </summary>
        public override string BlockName
        {
            get
            {
                return "decal_block";
            }
        }
        /// <summary>
        /// Gets and returns the display name of the decal_block tag block.
        /// </summary>
        public override string DisplayName
        {
            get
            {
                return "decal";
            }
        }
        /// <summary>
        /// Gets and returns the maximum number of elements allowed of the decal_block tag block.
        /// </summary>
        public override int MaximumElementCount
        {
            get
            {
                return 1;
            }
        }
        /// <summary>
        /// Gets and returns the alignment of the decal_block tag block.
        /// </summary>
        public override int Alignment
        {
            get
            {
                return 4;
            }
        }
    }
}
